/*	XdevL eXtended DEVice Library.	Copyright Â© 2005-2013 Cengiz Terzibas	This library is free software; you can redistribute it and/or modify it under the	terms of the GNU Lesser General Public License as published by the Free Software	Foundation; either version 2.1 of the License, or (at your option) any later version.	This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;	without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public License along with	this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place,	Suite 330, Boston, MA 02111-1307 USA	I would appreciate if you report all bugs to: cengiz@terzibas.de*/#include <sstream>#include <Carbon/Carbon.h>#include "XdevLWindowDeviceMacOSX.h"extern "C" XDEVL_EXPORT int _createWindowDevice(xdl::XdevLModuleCreateParameter* parameter) {	if(std::string(xdl::XdevLWindowDeviceImpl::m_windowModuleDesc.getName()) == parameter->getModuleName()) {		xdl::XdevLModule* obj = new xdl::XdevLWindowDeviceMacOSX(parameter);		if (!obj)			return xdl::ERR_ERROR;		parameter->setModuleInstance(obj);		return xdl::ERR_OK;	}	return xdl::ERR_MODULE_NOT_FOUND;}namespace xdl {xdl_int XdevLWindowDeviceMacOSX::init() {	// Do the internal initialization.	if(XdevLWindowDeviceImpl::init() == ERR_ERROR) {		return ERR_ERROR;	}	ProcessSerialNumber psn = {0, kCurrentProcess};	if( GetCurrentProcess( &psn ) != noErr ) {		XDEVL_MODULE_ERROR("Failed to get the process serial number\n");		return ERR_ERROR;	}	if( TransformProcessType( &psn, kProcessTransformToForegroundApplication ) != noErr ) {		XDEVL_MODULE_ERROR("Failed to become a foreground application\n");		return ERR_ERROR;	}	if(getFullscreen()) {		if( SetFrontProcess( &psn ) != noErr ) {			XDEVL_MODULE_ERROR("Failed to become the front process\n");			return ERR_ERROR;		}	}	unsigned int windowAttributes;	Rect windowContentBounds;	windowContentBounds.left = 0;	windowContentBounds.top = 0;	windowContentBounds.right = getWidth();	windowContentBounds.bottom = getHeight();	windowAttributes = ( kWindowCloseBoxAttribute |	                     kWindowCollapseBoxAttribute |	                     kWindowStandardHandlerAttribute );	windowAttributes |= kWindowLiveResizeAttribute;	// Create the main window.	if(CreateNewWindow( kDocumentWindowClass, windowAttributes, &windowContentBounds, &( m_windowRef) ) != noErr) {		return ERR_ERROR;	}		// Set background to black.	SetThemeWindowBackground(m_windowRef, kThemeBrushBlack, true);	// Set title of the window.	CFStringRef titleref = CFStringCreateWithCString(kCFAllocatorDefault, m_title.c_str(), kCFStringEncodingISOLatin1);	SetWindowTitleWithCFString(m_windowRef, titleref);	CFRelease(titleref);	// Set window position.	MoveWindow(m_windowRef, m_x, m_y, FALSE);	// Set the size again.	SizeWindow(m_windowRef, m_width, m_height, TRUE);	// Install the event handler.	InstallStandardEventHandler(GetWindowEventTarget(m_windowRef));	// Hide the mouse pointer.	this->setHidePointer(m_hideMouse);	// Display window.	this->show(true);	OIS::ParamList pl;	std::ostringstream windowHndStr;	windowHndStr << (unsigned int)(m_windowRef);	pl.insert(std::make_pair(std::string("WINDOW"), windowHndStr.str()));	if (!getFullscreen()) {		pl.insert(std::make_pair(std::string("MacAutoRepeatOn"), std::string("true")));	}	m_inputManager 		= OIS::InputManager::createInputSystem( pl );	if(m_inputManager == NULL) {		XDEVL_MODULE_ERROR("Could not create OIS Input System.\n");	}else{		m_inputManager->enableAddOnFactory(OIS::InputManager::AddOn_All);	}	return ERR_OK;}xdl_int XdevLWindowDeviceMacOSX::shutdown() {	// If the mouse was hidden show it again.	if(m_hideMouse) {		CGDisplayShowCursor(kCGDirectMainDisplay);		CGAssociateMouseAndMouseCursorPosition(true);	}	// Destroy the input system.	if(m_inputManager)		OIS::InputManager::destroyInputSystem(m_inputManager);	// Release the window resources.	if(m_windowRef)		ReleaseWindow(m_windowRef);	return ERR_OK;}xdl_int XdevLWindowDeviceMacOSX::update() {	EventRef event;	EventTargetRef eventDispatcher = GetEventDispatcherTarget();	while ( ReceiveNextEvent( 0, NULL, kEventDurationNoWait, TRUE, &event ) == noErr ) {		SendEventToEventTarget( event, eventDispatcher );		switch(GetEventKind(event)) {			case kEventWindowClose: {				// TODO Do something if the window receives the close window event.			} break;			case kEventWindowBoundsChanged: {				Rect rect;				GetWindowPortBounds(m_windowRef, &rect);				m_width = rect.right;				m_height = rect.bottom;				std::cout << rect.left << "," << rect.top << "," << rect.right << "," << rect.bottom << std::endl;			} break;			case kEventWindowDragCompleted: {			} break;		}		ReleaseEvent( event );	}	return ERR_OK;}xdl_int XdevLWindowDeviceMacOSX::recvEvent(XdevLEvent ev) {	return ERR_OK;}void* XdevLWindowDeviceMacOSX::getInternal(const char* id) {	std::string data(id);	if (data == "OIS_INPUTMANAGER")		return m_inputManager;	if (data == "OIS_WINDOW")		return m_windowRef;	return NULL;}void XdevLWindowDeviceMacOSX::setFullscreen(xdl_bool state) {	CFArrayRef availableModes = CGDisplayAvailableModes( kCGDirectMainDisplay );	CFIndex numberOfAvailableModes = CFArrayGetCount( availableModes );}xdl_int XdevLWindowDeviceMacOSX::show(xdl_bool state) {		// Do we have a valid window object?	if(m_windowRef == NULL)		return ERR_ERROR;	// Display window.	ShowWindow(m_windowRef);		// Set the focus of the window.	SelectWindow(m_windowRef);	return ERR_OK;}void XdevLWindowDeviceMacOSX::setX(xdl_uint x) {	// Set the internal X position value.	XdevLWindowDeviceImpl::setX(x);	// Set window position.	MoveWindow(m_windowRef, m_x, m_y, FALSE);}void XdevLWindowDeviceMacOSX::setY(xdl_uint y) {	// Set the internal X position value.	XdevLWindowDeviceImpl::setY(y);	// Set window position.	MoveWindow(m_windowRef, m_x, m_y, FALSE);}void XdevLWindowDeviceMacOSX::setWidth(xdl_uint width) {	// Set the internal width value.	XdevLWindowDeviceImpl::setWidth(width);	// Set the size again.	SizeWindow(m_windowRef, m_width, m_height, TRUE);}void XdevLWindowDeviceMacOSX::setHeight(xdl_uint height) {	// Set the internal width value.	XdevLWindowDeviceImpl::setHeight(height);	// Set the size again.	SizeWindow(m_windowRef, m_width, m_height, TRUE);}void XdevLWindowDeviceMacOSX::setTitle(const xdl_char* title) {	// Set the internal title value.	XdevLWindowDeviceImpl::setTitle(title);	// Set title of the window.	CFStringRef titleref = CFStringCreateWithCString(kCFAllocatorDefault, m_title.c_str(), kCFStringEncodingISOLatin1);	SetWindowTitleWithCFString(m_windowRef, titleref);	CFRelease(titleref);}void XdevLWindowDeviceMacOSX::setHidePointer(xdl_bool state) {	// Set the internal hide pointer state.	XdevLWindowDeviceImpl::setHidePointer(state);	// Hide or Show the cursor.	if(m_hideMouse) {		CGDisplayHideCursor(kCGDirectMainDisplay);		CGAssociateMouseAndMouseCursorPosition(false);	} else {		CGDisplayShowCursor(kCGDirectMainDisplay);		CGAssociateMouseAndMouseCursorPosition(true);	}}} // End of namespace