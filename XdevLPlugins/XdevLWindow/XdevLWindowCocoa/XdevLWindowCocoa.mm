/*	XdevL eXtended DEVice Library.	Copyright Â© 2005-2015 Cengiz Terzibas	This library is free software; you can redistribute it and/or modify it under the	terms of the GNU Lesser General Public License as published by the Free Software	Foundation; either version 2.1 of the License, or (at your option) any later version.	This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;	without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public License along with	this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place,	Suite 330, Boston, MA 02111-1307 USA	I would appreciate if you report all bugs to: cengiz@terzibas.de*/#include <sstream>#include "XdevLWindowCocoa.h"#include <XdevLInputSystem.h>static xdl::xdl_int reference_counter = 0;static id applicationDelegate = 0;static xdl::xdl_bool cocoaInitialized = xdl::xdl_false;static std::shared_ptr<xdl::XdevLCococaInit> cocoaInit;xdl::XdevLPluginDescriptor windowCocoaPluginDescriptor {	xdl::windowPluginName,	xdl::window_moduleNames,	XDEVLCOCOA_MAJOR_VERSION,	XDEVLCOCOA_MINOR_VERSION,	XDEVLCOCOA_PATCH_VERSION};xdl::XdevLModuleDescriptor windowCocoaDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[xdl::XDEVL_WINDOW_MODULE_NAME],	xdl::window_copyright,	xdl::windowDescription,	XDEVLCOCOA_MODULE_MAJOR_VERSION,	XDEVLCOCOA_MODULE_MINOR_VERSION,	XDEVLCOCOA_MODULE_PATCH_VERSION};xdl::XdevLModuleDescriptor windowServerCocoaDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[xdl::XDEVL_WINDOW_SERVER_MODULE_NAME],	xdl::window_copyright,	xdl::windowServerDescription,	XDEVLCOCOA_WINDOW_SERVER_MODULE_MAJOR_VERSION,	XDEVLCOCOA_WINDOW_SERVER_MODULE_MINOR_VERSION,	XDEVLCOCOA_WINDOW_SERVER_MODULE_PATCH_VERSION};xdl::XdevLModuleDescriptor windowEventServerCocoaDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[xdl::XDEVL_WINDOW_EVENT_SERVER_MODULE_NAME],	xdl::window_copyright,	xdl::windowServerDescription,	XDEVLCOCOA_WINDOW_EVENT_SERVER_MODULE_MAJOR_VERSION,	XDEVLCOCOA_WINDOW_EVENT_SERVER_MODULE_MINOR_VERSION,	XDEVLCOCOA_WINDOW_EVENT_SERVER_MODULE_PATCH_VERSION};extern xdl::XdevLModuleDescriptor cursorCocoaDesc;namespace xdl {	XdevLCococaInit::XdevLCococaInit(XdevLCoreMediator* core) {		if(xdl_true == cocoaInitialized) {			return;		}		if(NSApp == nil) {			[XdevLCocoaApplication sharedApplication];[NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];[NSApp activateIgnoringOtherApps:YES];			[NSApp finishLaunching];			id menubar = [[NSMenu new] autorelease];			id appMenuItem = [[NSMenuItem new] autorelease];[menubar addItem:appMenuItem];[NSApp setMainMenu:menubar];			id appMenu = [[NSMenu new] autorelease];			id appName = [[NSProcessInfo processInfo] processName];id quitTitle = [@"Quit " stringByAppendingString:appName];id quitMenuItem = [[[NSMenuItem alloc] initWithTitle:quitTitle                    action:@selector(terminate:) keyEquivalent:@"q"] autorelease];[appMenu addItem:quitMenuItem];[appMenuItem setSubmenu:appMenu];			applicationDelegate = [[XdevLApplicationDelegate alloc] init];			if(applicationDelegate != nil) {[		NSApp setDelegate:applicationDelegate];			} else {				std::cerr << "Could not create Application delegate" << std::endl;			}		}		XdevLModuleCreateParameter cparameter;		cparameter.setModuleId(XdevLID("XdevLWindowEventServer"));		windowEventServer = std::make_shared<XdevLWindowEventServerCocoa>(&cparameter, windowEventServerCocoaDesc);		if(core) {			core->registerModule(windowEventServer);		}		cparameter.setModuleId(XdevLID("XdevLCursor"));		cursor = std::make_shared<XdevLCursorCocoa>(&cparameter, cursorCocoaDesc);		if(core) {			core->registerModule(cursor);		}		cocoaInitialized = xdl_true;	}	XdevLCococaInit::~XdevLCococaInit() {		if(NSApp != nil) {[NSApp setDelegate:nil];		}	}//////	XdevLWindowCocoa::XdevLWindowCocoa(XdevLModuleCreateParameter* parameter, const XdevLModuleDescriptor& desriptor) :		XdevLWindowImpl(XdevLWindowImpl::getWindowsCounter(), parameter, desriptor),		m_window(0) {		XDEVL_MODULE_INFO("XdevLWindowCocoa()\n");		if(reference_counter == 0) {			XdevLCoreMediator* mediator = nullptr;			if(nullptr != parameter) {				mediator = parameter->getMediator();			}			XdevLWindowCocoa::initCocoa(mediator);		}		reference_counter++;	}	XdevLWindowCocoa::~XdevLWindowCocoa() {		XDEVL_MODULE_INFO("~XdevLWindowCocoa()\n");		if(reference_counter == 1) {			XdevLWindowCocoa::shutdownCocoa();		}		reference_counter--;	}	xdl_int XdevLWindowCocoa::initCocoa(XdevLCoreMediator* core) {		if(nullptr != cocoaInit) {			return ERR_OK;		}		cocoaInit = std::make_shared<XdevLCococaInit>(core);		return xdl::ERR_OK;	}	xdl_int XdevLWindowCocoa::shutdownCocoa() {		return ERR_OK;	}	xdl_int XdevLWindowCocoa::init() {		// Do the internal initialization.		if(XdevLWindowImpl::init() == ERR_ERROR) {			return ERR_ERROR;		}		return ERR_OK;	}	xdl_int XdevLWindowCocoa::shutdown() {[m_window orderOut:nil];[m_window setDelegate:nil];		[m_delegate release];		m_delegate = nil;		[m_view release];		m_view = nil;		[m_window close];		m_window = nil;		return ERR_OK;	}	xdl_int XdevLWindowCocoa::create(const XdevLWindowAttribute& attribute) {		XdevLWindowImpl::create(attribute);		return create();	}	xdl_int XdevLWindowCocoa::create() {		NSAutoreleasePool*	pool = [[NSAutoreleasePool alloc] init];		//		// Create the event delegate		//m_delegate = [[XdevLWindowDelegate alloc] init:cocoaInit->getWindowEventServer() :this];		if(m_delegate == nil) {			XDEVL_MODULE_ERROR("Could not create XdevLWindowDelegate\n");			return ERR_ERROR;		}		//		// Set type of the window		//		xdl_uint style = 0;		if(getType() == XDEVL_WINDOW_TYPE_NORMAL) {			style = (NSTitledWindowMask|NSClosableWindowMask|NSMiniaturizableWindowMask|NSResizableWindowMask);		} else {			style = NSBorderlessWindowMask;		}		XdevLWindowPosition position = getPosition();		XdevLWindowSize size = getSize();		NSRect rect;		rect.origin.x = position.x;		rect.origin.y = position.y;		rect.size.width = size.width;		rect.size.height = size.height;		NSArray* screens = [NSScreen screens];		NSScreen *screen = nil;		for(NSScreen* candidate in screens) {			NSRect screenRect = [candidate frame];			if(rect.origin.x >= screenRect.origin.x &&			    rect.origin.x < screenRect.origin.x + screenRect.size.width &&			    rect.origin.y >= screenRect.origin.y &&			    rect.origin.y < screenRect.origin.y + screenRect.size.height) {				screen = candidate;				rect.origin.x -= screenRect.origin.x;				rect.origin.y -= screenRect.origin.y;			}		}		@try {m_window = [[NSWindow alloc] initWithContentRect:rect styleMask:style backing:NSBackingStoreBuffered defer:NO screen:screen];		}		@catch(NSException *e) {			XDEVL_MODULE_ERROR([[e reason] UTF8String] << std::endl);			[pool release];			return ERR_ERROR;		}		m_view = [[XdevLContentView alloc] init:cocoaInit->getWindowEventServer() :this];		[m_window setTitle:[NSString stringWithUTF8String:getTitle().toString().c_str()]];		[m_window setContentView: m_view];		[m_window setDelegate:m_delegate];		[m_window setAcceptsMouseMovedEvents:YES];		[m_window makeKeyAndOrderFront:nil];		[pool release];		return ERR_OK;	}	xdl_int XdevLWindowCocoa::update() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		for(;;) {NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask                  untilDate:[NSDate distantPast]                  inMode:NSDefaultRunLoopMode                  dequeue:YES];			if(event == nil)				break;[NSApp sendEvent:event];		}		return ERR_ERROR;	}	void* XdevLWindowCocoa::getInternal(const XdevLInternalName& id) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		if(id == XdevLString("COCOA_WIN")) {			return m_window;		} else if(id == XdevLString("COCOA_VIEW")) {			return m_view;		}		return nullptr;	}	const XdevLWindowPosition& XdevLWindowCocoa::getPosition() {		return XdevLWindowImpl::getPosition();	}	const XdevLWindowSize& XdevLWindowCocoa::getSize() {		return XdevLWindowImpl::getSize();	}	XdevLWindowPosition::type XdevLWindowCocoa::getX() {		return XdevLWindowImpl::getX();	}	XdevLWindowPosition::type XdevLWindowCocoa::getY() {		return XdevLWindowImpl::getY();	}	XdevLWindowSize::type XdevLWindowCocoa::getWidth() {		return XdevLWindowImpl::getWidth();	}	XdevLWindowSize::type XdevLWindowCocoa::getHeight() {		return XdevLWindowImpl::getHeight();	}	const XdevLWindowTitle& XdevLWindowCocoa::getTitle() {		return XdevLWindowImpl::getTitle();	}	xdl_bool  XdevLWindowCocoa::isFullscreen() {		return XdevLWindowImpl::isFullscreen();	}	void XdevLWindowCocoa::setFullscreen(xdl_bool state) {	}	void XdevLWindowCocoa::setX(XdevLWindowPosition::type x) {		XdevLWindowImpl::setX(x);	}	void XdevLWindowCocoa::setY(XdevLWindowPosition::type y) {		XdevLWindowImpl::setY(y);	}	void XdevLWindowCocoa::setWidth(XdevLWindowSize::type width) {		XdevLWindowImpl::setWidth(width);	}	void XdevLWindowCocoa::setHeight(XdevLWindowSize::type height) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		setHeight(height);		NSSize size;		size.width = getWidth();		setHeight(height);		size.height = height;[m_window setContentSize:size];		[pool release];	}	void XdevLWindowCocoa::setTitle(const XdevLWindowTitle& title) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		XdevLWindowImpl::setTitle(title);NSString* string = [[NSString alloc] initWithUTF8String:m_title.toString().c_str()];[m_window setTitle:string];		[string release];		[pool release];	}	xdl_bool XdevLWindowCocoa::isHidden() {		return xdl_false;	}	void XdevLWindowCocoa::raise() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[m_window orderFront:nil];		[pool release];	}	xdl_bool XdevLWindowCocoa::isPointerHidden() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		return XdevLWindowImpl::isPointerHidden();	}	void XdevLWindowCocoa::setInputFocus() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		[m_window makeKeyWindow];		[pool release];	}	void XdevLWindowCocoa::show() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[m_window orderFront:nil];		[pool release];	}	void XdevLWindowCocoa::hide() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[m_window orderOut:nil];		[pool release];	}	void XdevLWindowCocoa::setSize(const XdevLWindowSize& size) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		setSize(size);	}	void XdevLWindowCocoa::setPosition(const XdevLWindowPosition& position) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		setPosition(position);	}	xdl_bool XdevLWindowCocoa::hasFocus() {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		BOOL value = FALSE;		[[m_window keyWindow] value];		xdl_bool focus = (value == YES) ? xdl_true : xdl_false;		[pool release];		return focus;	}	void XdevLWindowCocoa::setType(XdevLWindowTypes type) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		setType(type);	}	void XdevLWindowCocoa::setParent(XdevLWindow* window) {		XDEVL_ASSERT(m_window != 0, "Window is not created.");		XdevLWindowImpl::setParent(window);	}} // End of namespace@implementation XdevLWindowDelegate- (id)init:(xdl::XdevLWindowEventServerCocoa *)windowEventServer :(xdl::XdevLWindowCocoa*)window {	self = [super init];	if(self != nil) {		m_windowEventServer = windowEventServer;		m_window = window;	}	return self;}- (BOOL)windowShouldClose:(id)sender {	xdl::XdevLEvent ev;	ev.type					= xdl::XDEVL_WINDOW_EVENT;	ev.window.event 		= xdl::XDEVL_WINDOW_CLOSE;	ev.window.windowid		= m_window->getWindowID();	m_window->getMediator()->fireEvent(ev);	// Make a core event.	ev.type					= xdl::XDEVL_CORE_EVENT;	ev.core.event 			= xdl::XDEVL_CORE_SHUTDOWN;	m_window->getMediator()->fireEvent(ev);	return NO;}- (void)windowDidResize:(NSNotification *)notification {}- (void)windowDidMove:(NSNotification *)notification {}- (void)windowDidMiniaturize:(NSNotification *)notification {}- (void)windowDidDeminiaturize:(NSNotification *)notification {}- (void)windowDidBecomeKey:(NSNotification *)notification {}- (void)windowDidResignKey:(NSNotification *)notification {}@end//////@implementation XdevLApplicationDelegate- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender {	return NSTerminateCancel;}- (void)applicationDidHide:(NSNotification *)notification {	std::cout << "applicationDidHide" << std::endl;}- (void)applicationDidUnhide:(NSNotification *)notification {	std::cout << "applicationDidUnhide" << std::endl;}- (void)applicationDidChangeScreenParameters:(NSNotification *) notification {	std::cout << "applicationDidChangeScreenParameters" << std::endl;}@end//////@implementation XdevLCocoaApplication// From http://cocoadev.com/index.pl?GameKeyboardHandlingAlmost// This works around an AppKit bug, where key up events while holding// down the command key don't get sent to the key window.- (void)sendEvent:(NSEvent *)event {	if([event type] == NSKeyUp && ([event modifierFlags] & NSCommandKeyMask))[[self keyWindow] sendEvent:event];	else[super sendEvent:event];}@end