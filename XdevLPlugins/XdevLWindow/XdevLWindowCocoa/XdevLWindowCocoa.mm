/*	XdevL eXtended DEVice Library.	Copyright Â© 2005-2013 Cengiz Terzibas	This library is free software; you can redistribute it and/or modify it under the	terms of the GNU Lesser General Public License as published by the Free Software	Foundation; either version 2.1 of the License, or (at your option) any later version.	This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;	without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public License along with	this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place,	Suite 330, Boston, MA 02111-1307 USA	I would appreciate if you report all bugs to: cengiz@terzibas.de*/#include <sstream>#include "XdevLWindowCocoa.h"#include <XdevLInputSystem.h>xdl::XdevLModuleDescriptor windowCocoaModuleDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[0],	xdl::window_copyright,	xdl::windowDescription,	xdl::XdevLWindowMajorVersion,	xdl::XdevLWindowMinorVersion,	xdl::XdevLWindowPatchVersion};xdl::XdevLModuleDescriptor windowEventServerModuleDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[2],	xdl::window_copyright,	xdl::windowServerDescription,	xdl::XdevLWindowEventServerMajorVersion,	xdl::XdevLWindowEventServerMinorVersion,	xdl::XdevLWindowEventServerPatchVersion};xdl::XdevLModuleDescriptor cursorModuleDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[3],	xdl::window_copyright,	xdl::windowServerDescription,	xdl::XdevLWindowEventServerMajorVersion,	xdl::XdevLWindowEventServerMinorVersion,	xdl::XdevLWindowEventServerPatchVersion};xdl::XdevLPluginDescriptor m_windowCarbonPluginDescriptor {	xdl::windowPluginName,	xdl::window_moduleNames,	xdl::XdevLWindowPluginMajorVersion,	xdl::XdevLWindowPluginMinorVersion,	xdl::XdevLWindowPluginPatchVersion};static xdl::xdl_int reference_counter = 0;static id applicationDelegate = 0;xdl::XdevLWindowCocoaEventServer* windowEventServerCocoa = nullptr;extern "C" XDEVL_EXPORT int _create(xdl::XdevLModuleCreateParameter* parameter) {	if(reference_counter == 0) {		if(NSApp == nil) {			[XdevLCocoaApplication sharedApplication];			[NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];			[NSApp finishLaunching];			applicationDelegate = [[XdevLApplicationDelegate alloc] init];			if(applicationDelegate != nil) {				[NSApp setDelegate:applicationDelegate];			} else {				std::cerr << "Could not create Application delegate" << std::endl;			}		}		reference_counter++;		// If there is not event server first create one.		if(xdl::windowEventServer == nullptr) {			// If there is no even server active, create and activate it.			xdl::windowEventServer = static_cast<xdl::XdevLWindowCocoaEventServer*>(parameter->getMediator()->createModule(xdl::XdevLModuleName("XdevLWindowEventServer"), xdl::XdevLID("XdevLWindowEventServer"), xdl::XdevLPluginName("XdevLWindowCocoa")));		}	}	if(windowCocoaModuleDesc.getName() == parameter->getModuleName()) {		xdl::XdevLWindowCocoa* window = new xdl::XdevLWindowCocoa(parameter);		parameter->setModuleInstance(window);	} else if(xdl::XdevLWindowServerImpl::m_windowServerModuleDesc.getName() == parameter->getModuleName()) {		xdl::XdevLWindowCocoaEventServer* windowServer = new xdl::XdevLWindowCocoaEventServer(parameter);		parameter->setModuleInstance(windowServer);	}  else if(cursorModuleDesc.getName() == parameter->getModuleName()) {		xdl::XdevLCursorCocoa* cursor = new xdl::XdevLCursorCocoa(parameter);		parameter->setModuleInstance(cursor);	} else if(windowEventServerModuleDesc.getName() == parameter->getModuleName()) {		windowEventServerCocoa = new xdl::XdevLWindowCocoaEventServer(parameter);		xdl::windowEventServer = windowEventServerCocoa;		parameter->setModuleInstance(xdl::windowEventServer);		xdl::XdevLWindowEventServerParameter = parameter;	} else {		return xdl::ERR_MODULE_NOT_FOUND;	}	return xdl::ERR_OK;}extern "C" XDEVL_EXPORT void _delete(xdl::XdevLModule* obj) {	if(obj)		delete obj;	reference_counter--;	// Only Quit SDL if this is the last module.	if(reference_counter == 0) {		// If the last window was destroy make sure to destroy the event server too.		if(xdl::windowEventServer != nullptr) {			xdl::XdevLWindowEventServerParameter->getMediator()->deleteModule(xdl::windowEventServer->getID());			xdl::windowEventServer = nullptr;		}	}}extern "C" XDEVL_EXPORT xdl::XdevLPluginDescriptor* _getDescriptor()  {	return &m_windowCarbonPluginDescriptor;}namespace xdl {	const XdevLID ButtonPressed("XDEVL_BUTTON_PRESSED");	const XdevLID ButtonReleased("XDEVL_BUTTON_RELEASED");	const XdevLID MouseButtonPressed("XDEVL_MOUSE_BUTTON_PRESSED");	const XdevLID MouseButtonReleased("XDEVL_MOUSE_BUTTON_RELEASED");	const XdevLID MouseMotion("XDEVL_MOUSE_MOTION");	const XdevLID WindowEvent("XDEVL_WINDOW_EVENT");static int translateKey(unsigned int key){    // Keyboard symbol translation table    static const unsigned int table[128] =    {        /* 00 */ KEY_A,        /* 01 */ KEY_S,        /* 02 */ KEY_D,        /* 03 */ KEY_F,        /* 04 */ KEY_H,        /* 05 */ KEY_G,        /* 06 */ KEY_Z,        /* 07 */ KEY_X,        /* 08 */ KEY_C,        /* 09 */ KEY_V,        /* 0a */ KEY_UNKNOWN,        /* 0b */ KEY_B,        /* 0c */ KEY_Q,        /* 0d */ KEY_W,        /* 0e */ KEY_E,        /* 0f */ KEY_R,        /* 10 */ KEY_Y,        /* 11 */ KEY_T,        /* 12 */ KEY_1,        /* 13 */ KEY_2,        /* 14 */ KEY_3,        /* 15 */ KEY_4,        /* 16 */ KEY_6,        /* 17 */ KEY_5,        /* 18 */ KEY_EQUALS,        /* 19 */ KEY_9,        /* 1a */ KEY_7,        /* 1b */ KEY_MINUS,        /* 1c */ KEY_8,        /* 1d */ KEY_0,        /* 1e */ KEY_RIGHTBRACKET,        /* 1f */ KEY_O,        /* 20 */ KEY_U,        /* 21 */ KEY_LEFTBRACKET,        /* 22 */ KEY_I,        /* 23 */ KEY_P,        /* 24 */ KEY_ENTER,        /* 25 */ KEY_L,        /* 26 */ KEY_J,        /* 27 */ KEY_APOSTROPHE,        /* 28 */ KEY_K,        /* 29 */ KEY_SEMICOLON,        /* 2a */ KEY_BACKSLASH,        /* 2b */ KEY_COMMA,        /* 2c */ KEY_SLASH,        /* 2d */ KEY_N,        /* 2e */ KEY_M,        /* 2f */ KEY_PERIOD,        /* 30 */ KEY_TAB,        /* 31 */ KEY_SPACE,        /* 32 */ KEY_GRAVE,        /* 33 */ KEY_BACKSPACE,        /* 34 */ KEY_UNKNOWN,        /* 35 */ KEY_ESCAPE,        /* 36 */ KEY_RGUI,        /* 37 */ KEY_LGUI,        /* 38 */ KEY_LSHIFT,        /* 39 */ KEY_CAPSLOCK,        /* 3a */ KEY_LALT,        /* 3b */ KEY_LCTRL,        /* 3c */ KEY_RSHIFT,        /* 3d */ KEY_RALT,        /* 3e */ KEY_RCTRL,        /* 3f */ KEY_UNKNOWN, /* Function */        /* 40 */ KEY_F17,        /* 41 */ KEY_KP_PERIOD,        /* 42 */ KEY_UNKNOWN,        /* 43 */ KEY_KP_MULTIPLY,        /* 44 */ KEY_UNKNOWN,        /* 45 */ KEY_KP_PLUS,        /* 46 */ KEY_UNKNOWN,        /* 47 */ KEY_NUMLOCK, /* Really KeypadClear... */        /* 48 */ KEY_UNKNOWN, /* VolumeUp */        /* 49 */ KEY_UNKNOWN, /* VolumeDown */        /* 4a */ KEY_UNKNOWN, /* Mute */        /* 4b */ KEY_KP_DIVIDE,        /* 4c */ KEY_KP_ENTER,        /* 4d */ KEY_UNKNOWN,        /* 4e */ KEY_KP_MINUS,        /* 4f */ KEY_F18,        /* 50 */ KEY_F19,        /* 51 */ KEY_KP_ENTER,        /* 52 */ KEY_KP_0,        /* 53 */ KEY_KP_1,        /* 54 */ KEY_KP_2,        /* 55 */ KEY_KP_3,        /* 56 */ KEY_KP_4,        /* 57 */ KEY_KP_5,        /* 58 */ KEY_KP_6,        /* 59 */ KEY_KP_7,        /* 5a */ KEY_F20,        /* 5b */ KEY_KP_8,        /* 5c */ KEY_KP_9,        /* 5d */ KEY_UNKNOWN,        /* 5e */ KEY_UNKNOWN,        /* 5f */ KEY_UNKNOWN,        /* 60 */ KEY_F5,        /* 61 */ KEY_F6,        /* 62 */ KEY_F7,        /* 63 */ KEY_F3,        /* 64 */ KEY_F8,        /* 65 */ KEY_F9,        /* 66 */ KEY_UNKNOWN,        /* 67 */ KEY_F11,        /* 68 */ KEY_UNKNOWN,        /* 69 */ KEY_F13,        /* 6a */ KEY_F16,        /* 6b */ KEY_F14,        /* 6c */ KEY_UNKNOWN,        /* 6d */ KEY_F10,        /* 6e */ KEY_UNKNOWN,        /* 6f */ KEY_F12,        /* 70 */ KEY_UNKNOWN,        /* 71 */ KEY_F15,        /* 72 */ KEY_INSERT,        /* 73 */ KEY_HOME,        /* 74 */ KEY_PAGEUP,        /* 75 */ KEY_DELETE,        /* 76 */ KEY_F4,        /* 77 */ KEY_END,        /* 78 */ KEY_F2,        /* 79 */ KEY_PAGEDOWN,        /* 7a */ KEY_F1,        /* 7b */ KEY_LEFT,        /* 7c */ KEY_RIGHT,        /* 7d */ KEY_DOWN,        /* 7e */ KEY_UP,        /* 7f */ KEY_UNKNOWN,    };    if (key >= 128)        return KEY_UNKNOWN;    return table[key];}static int translateFlags(NSUInteger flags){    int mods = 0;    if (flags & NSShiftKeyMask)        mods |= KEY_MOD_LSHIFT;    if (flags & NSControlKeyMask)        mods |= KEY_MOD_LCTRL;    if (flags & NSAlternateKeyMask)        mods |= KEY_MOD_LALT;    if (flags & NSCommandKeyMask)        mods |= KEY_MOD_LGUI;    return mods;}	XdevLWindowCocoa::XdevLWindowCocoa(XdevLModuleCreateParameter* parameter) :		XdevLWindowImpl(XdevLWindowImpl::getWindowsCounter(), parameter, windowCocoaModuleDesc) {	}	xdl_int XdevLWindowCocoa::init() {		// Do the internal initialization.		if(XdevLWindowImpl::init() == ERR_ERROR) {			return ERR_ERROR;		}		return create();	}	xdl_int XdevLWindowCocoa::shutdown() {		return ERR_ERROR;	}	xdl_int XdevLWindowCocoa::create() {		NSAutoreleasePool*	pool = [[NSAutoreleasePool alloc] init];		NSRect 				rect;		NSArray*			screens = [NSScreen screens];		m_delegate = [[XdevLWindowDelegate alloc] init:windowEventServerCocoa :this];		if(m_delegate == nil) {			XDEVL_MODULE_ERROR("Could not create XdevLWindowDelegate\n");			return ERR_ERROR;		}		xdl_uint 			style = 0;		if(getType() == WINDOW_NORMAL) {			style = (NSTitledWindowMask|NSClosableWindowMask|NSMiniaturizableWindowMask|NSResizableWindowMask);		} else {			style = NSBorderlessWindowMask;		}		rect.origin.x		= m_position.x;		rect.origin.y		= m_position.y;		rect.size.width		= m_size.width;		rect.size.height	= m_size.height;		NSScreen *screen = nil;		for(NSScreen* candidate in screens) {			NSRect screenRect = [candidate frame];			if(rect.origin.x >= screenRect.origin.x &&			        rect.origin.x < screenRect.origin.x + screenRect.size.width &&			        rect.origin.y >= screenRect.origin.y &&			        rect.origin.y < screenRect.origin.y + screenRect.size.height) {				screen = candidate;				rect.origin.x -= screenRect.origin.x;				rect.origin.y -= screenRect.origin.y;			}		}		@try {m_window = [[NSWindow alloc] initWithContentRect:rect styleMask:style backing:NSBackingStoreBuffered defer:NO screen:screen];		}		@catch(NSException *e) {			XDEVL_MODULE_ERROR([[e reason] UTF8String] << std::endl);			[pool release];			return ERR_ERROR;		}		m_view = [[XdevLContentView alloc] init:windowEventServerCocoa];		[m_window setTitle:[NSString stringWithUTF8String:m_title.toString().c_str()]];		[m_window setContentView: m_view];		[m_window setDelegate:m_delegate];		[m_window setAcceptsMouseMovedEvents:YES];//		[m_window center];//		[m_window registerForDraggedTypes:[NSArray arrayWithObject:(NSString *)kUTTypeFileURL]];		[pool release];		return ERR_OK;	}	xdl_int XdevLWindowCocoa::update() {		for (;;)		{			NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask												untilDate:[NSDate distantPast]												   inMode:NSDefaultRunLoopMode												  dequeue:YES];			if (event == nil)				break;			[NSApp sendEvent:event];		}		return ERR_ERROR;	}	void* XdevLWindowCocoa::getInternal(const XdevLInternalName& id) {		return nullptr;	}	void XdevLWindowCocoa::showPointer() {	}	void XdevLWindowCocoa::hidePointer() {	}	void XdevLWindowCocoa::setPointerPosition(xdl_uint x, xdl_uint y) {	}	void XdevLWindowCocoa::clipPointerPosition(xdl_uint x, xdl_uint y, xdl_uint width, xdl_uint height)  {	}	void XdevLWindowCocoa::grabPointer() {	}	void XdevLWindowCocoa::ungrabPointer() {	}	void XdevLWindowCocoa::grabKeyboard() {	}	void XdevLWindowCocoa::ungrabKeyboard() {	}	const XdevLWindowPosition& XdevLWindowCocoa::getPosition() {		return m_position;	}	const XdevLWindowSize& XdevLWindowCocoa::getSize() {		return m_size;	}	XdevLWindowPosition::type XdevLWindowCocoa::getX() {		return m_position.x;	}	XdevLWindowPosition::type XdevLWindowCocoa::getY() {		return m_position.y;	}	XdevLWindowSize::type XdevLWindowCocoa::getWidth() {		return m_size.width;	}	XdevLWindowSize::type XdevLWindowCocoa::getHeight() {		return m_size.height;	}	const XdevLWindowTitle& XdevLWindowCocoa::getTitle() {		return m_title;	}	xdl_bool  XdevLWindowCocoa::getFullscreen() {		return XdevLWindowImpl::getFullscreen();	}	void XdevLWindowCocoa::setFullscreen(xdl_bool state) {	}	void XdevLWindowCocoa::show() {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		if(![m_window isMiniaturized]) {//			[windowData->listener pauseVisibleObservation];[m_window makeKeyAndOrderFront:nil];//			[windowData->listener resumeVisibleObservation];		}		[pool release];	}	void XdevLWindowCocoa::setX(XdevLWindowPosition::type x) {	}	void XdevLWindowCocoa::setY(XdevLWindowPosition::type y) {	}	void XdevLWindowCocoa::setWidth(XdevLWindowSize::type width) {	}	void XdevLWindowCocoa::setHeight(XdevLWindowSize::type height) {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		NSSize size;		size.width = getWidth();		setHeight(height);		size.height = getHeight();[m_window setContentSize:size];		[pool release];	}	void XdevLWindowCocoa::setTitle(const XdevLWindowTitle& title) {		m_title = title;		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];NSString* string = [[NSString alloc] initWithUTF8String:m_title.toString().c_str()];[m_window setTitle:string];		[string release];		[pool release];	}	xdl_int  XdevLWindowCocoa::getColorDepth() {		return XdevLWindowImpl::getColorDepth();	}	xdl_bool XdevLWindowCocoa::isHidden() {		return xdl_false; // TODO This may cause problems.	}	void XdevLWindowCocoa::raise() {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[m_window makeKeyAndOrderFront:nil];		[pool release];	}	xdl_bool  XdevLWindowCocoa::getHidePointer() {		return XdevLWindowImpl::getHidePointer();	}	void XdevLWindowCocoa::setInputFocus() {	}	void XdevLWindowCocoa::hide() {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[m_window orderOut:nil];		[pool release];	}	void XdevLWindowCocoa::setSize(const XdevLWindowSize& size) {		m_size = size;	}	void XdevLWindowCocoa::setPosition(const XdevLWindowPosition& position) {		m_position = position;	}	xdl_bool XdevLWindowCocoa::hasFocus() {		return xdl_false;	}	void XdevLWindowCocoa::setType(XdevLWindowTypes type) {		m_windowType = type;	}	void XdevLWindowCocoa::setParent(XdevLWindow* window) {		XdevLWindowImpl::setParent(window);	}	//	// -------------------------------------------------------------------------	//	XdevLWindowServerCocoa::XdevLWindowServerCocoa(XdevLModuleCreateParameter* parameter) :		XdevLWindowServerImpl(parameter) {	}	XdevLWindowServerCocoa::~XdevLWindowServerCocoa() {	}	xdl_int XdevLWindowServerCocoa::createWindow(XdevLWindow** window,	        const XdevLWindowTitle& title,	        const XdevLWindowPosition& position,	        const XdevLWindowSize& size) {//		XdevLWindowSDL* sdlWindow = new XdevLWindowSDL(nullptr);//		sdlWindow->setTitle(title);//		sdlWindow->setPosition(position);//		sdlWindow->setSize(size);//		sdlWindow->setWindowDecoration(xdl_false);//		sdlWindow->create();//		*window = sdlWindow;//		m_windowList[sdlWindow->getWindowID()] = sdlWindow;		return ERR_OK;	}	XdevLWindowCocoaEventServer::XdevLWindowCocoaEventServer(XdevLModuleCreateParameter* parameter) :		XdevLWindowEventServerImpl(parameter, windowEventServerModuleDesc)	{}	xdl_int XdevLWindowCocoaEventServer::registerWindowForEvents(XdevLWindow* window) {		return XdevLWindowEventServerImpl::registerWindowForEvents(window);	}	xdl_int XdevLWindowCocoaEventServer::unregisterWindowFromEvents(XdevLWindow* window) {		return XdevLWindowEventServerImpl::unregisterWindowFromEvents(window);	}	xdl_int XdevLWindowCocoaEventServer::init() {		XDEVL_MODULE_SUCCESS("Window created successfully" << std::endl);		return ERR_OK;	}	void* XdevLWindowCocoaEventServer::getInternal(const XdevLInternalName& id) {		return nullptr;	}	xdl_int XdevLWindowCocoaEventServer::shutdown() {		XDEVL_MODULE_SUCCESS("Shutdown process was successful.\n");		return ERR_OK;	}	xdl_int XdevLWindowCocoaEventServer::update() {		return ERR_ERROR;	}	void XdevLWindowCocoaEventServer::flush() {	}//// -----------------------------------------------------------------------------//	XdevLCursorCocoa::XdevLCursorCocoa(XdevLModuleCreateParameter* parameter) :		XdevLModuleImpl<XdevLCursor>(parameter, cursorModuleDesc)  {	}	xdl_int XdevLCursorCocoa::init() {		return ERR_OK;	}	xdl_int XdevLCursorCocoa::shutdown() {		return ERR_OK;	}	void* XdevLCursorCocoa::getInternal(const XdevLInternalName& id) {		return nullptr;	}	void XdevLCursorCocoa::show() {	}	void XdevLCursorCocoa::hide() {	}	void XdevLCursorCocoa::setPosition(xdl_uint x, xdl_uint y) {	}	xdl_int XdevLCursorCocoa::clip(xdl_uint x, xdl_uint y, xdl_uint width, xdl_uint height) {		return ERR_ERROR;	}	void XdevLCursorCocoa::releaseClip() {	}	xdl_int XdevLCursorCocoa::enableRelativeMotion() {		return ERR_ERROR;	}	void XdevLCursorCocoa::disableRelativeMotion() {	}} // End of namespace@implementation XdevLWindowDelegate- (id)init:(xdl::XdevLWindowCocoaEventServer *)windowEventServer :(xdl::XdevLWindowCocoa*)window {	self = [super init];	if(self != nil) {		m_windowEventServer = windowEventServer;		m_window = window;	}	return self;}- (BOOL)windowShouldClose:(id)sender {	xdl::XdevLEvent ev;	ev.type					= xdl::XDEVL_WINDOW_EVENT;	ev.window.event 		= xdl::XDEVL_WINDOW_CLOSE;	ev.window.windowid		= m_window->getWindowID();	m_window->getMediator()->fireEvent(ev);	// Make a core event.	ev.type					= xdl::XDEVL_CORE_EVENT;	ev.core.event 			= xdl::XDEVL_CORE_SHUTDOWN;	m_window->getMediator()->fireEvent(ev);	return NO;}- (void)windowDidResize:(NSNotification *)notification {//    [window->nsgl.context update];////    const NSRect contentRect = [window->ns.view frame];//    const NSRect fbRect = convertRectToBacking(window, contentRect);////    _glfwInputFramebufferSize(window, fbRect.size.width, fbRect.size.height);//    _glfwInputWindowSize(window, contentRect.size.width, contentRect.size.height);//    _glfwInputWindowDamage(window);////    if (window->cursorMode == GLFW_CURSOR_DISABLED)//        centerCursor(window);}- (void)windowDidMove:(NSNotification *)notification {//    [window->nsgl.context update];////    int x, y;//    _glfwPlatformGetWindowPos(window, &x, &y);//    _glfwInputWindowPos(window, x, y);////    if (window->cursorMode == GLFW_CURSOR_DISABLED)//        centerCursor(window);}- (void)windowDidMiniaturize:(NSNotification *)notification {//   _glfwInputWindowIconify(window, GL_TRUE);}- (void)windowDidDeminiaturize:(NSNotification *)notification {//    if (window->monitor)//        enterFullscreenMode(window);////    _glfwInputWindowIconify(window, GL_FALSE);}- (void)windowDidBecomeKey:(NSNotification *)notification {//    _glfwInputWindowFocus(window, GL_TRUE);//    _glfwPlatformSetCursorMode(window, window->cursorMode);}- (void)windowDidResignKey:(NSNotification *)notification {//    _glfwInputWindowFocus(window, GL_FALSE);//    _glfwPlatformSetCursorMode(window, GLFW_CURSOR_NORMAL);}@end@implementation XdevLContentView+ (void)initialize{    if (self == [XdevLContentView class])    {//        if (cursor == nil)//        {//            NSImage* data = [[NSImage alloc] initWithSize:NSMakeSize(16, 16)];//            cursor = [[NSCursor alloc] initWithImage:data//										hotSpot:NSZeroPoint];//            [data release];//        }    }}- (id)init:(xdl::XdevLWindowCocoaEventServer *)initWindow{    self = [super init];    if (self != nil)    {        windowEventServer = initWindow;        trackingArea = nil;        [self updateTrackingAreas];        [self registerForDraggedTypes:[NSArray arrayWithObjects:                                       NSFilenamesPboardType, nil]];    }    return self;}-(void)dealloc{    [trackingArea release];    [super dealloc];}- (BOOL)isOpaque{    return YES;}- (BOOL)canBecomeKeyView{    return YES;}- (BOOL)acceptsFirstResponder{    return YES;}- (void)cursorUpdate:(NSEvent *)event{  //  setModeCursor(window);}- (void)mouseDown:(NSEvent *)event{	std::cout << "Mouse Down" << std::endl;}- (void)mouseDragged:(NSEvent *)event{    [self mouseMoved:event];}- (void)mouseUp:(NSEvent *)event{	std::cout << "Left Mouse Up" << std::endl;}- (void)mouseMoved:(NSEvent *)event{	std::cout << "Left Mouse Moved" << std::endl;}- (void)rightMouseDown:(NSEvent *)event{	std::cout << "Right Mouse Down" << std::endl;}- (void)rightMouseDragged:(NSEvent *)event{    [self mouseMoved:event];}- (void)rightMouseUp:(NSEvent *)event{	std::cout << "Right Mouse Up" << std::endl;}- (void)otherMouseDown:(NSEvent *)event{	std::cout << "Other Mouse Down" << std::endl;}- (void)otherMouseDragged:(NSEvent *)event{    [self mouseMoved:event];}- (void)otherMouseUp:(NSEvent *)event{	std::cout << "Mouse Up" << std::endl;}- (void)mouseExited:(NSEvent *)event{	std::cout << "Leave Window" << std::endl;}- (void)mouseEntered:(NSEvent *)event{	std::cout << "Enter Window" << std::endl;}- (void)viewDidChangeBackingProperties{ //   const NSRect contentRect = [window->ns.view frame];  //  const NSRect fbRect = convertRectToBacking(window, contentRect);}- (void)updateTrackingAreas{    if (trackingArea != nil)    {        [self removeTrackingArea:trackingArea];        [trackingArea release];    }    NSTrackingAreaOptions options = NSTrackingMouseEnteredAndExited |                                    NSTrackingActiveInKeyWindow |                                    NSTrackingCursorUpdate |                                    NSTrackingInVisibleRect;    trackingArea = [[NSTrackingArea alloc] initWithRect:[self bounds]                                                options:options                                                  owner:self                                               userInfo:nil];    [self addTrackingArea:trackingArea];    [super updateTrackingAreas];}- (void)keyDown:(NSEvent *)event{    const int key = xdl::translateKey([event keyCode]);    const int mods = xdl::translateFlags([event modifierFlags]);//   _glfwInputKey(window, key, [event keyCode], GLFW_PRESS, mods); //   NSString* characters = [event characters]; //   NSUInteger i, length = [characters length]; //   for (i = 0;  i < length;  i++) //       _glfwInputChar(window, [characters characterAtIndex:i]);	xdl::XdevLEvent ev;	ev.common.timestamp 	= windowEventServer->getMediator()->getTimer().getTime64();	ev.type 				= xdl::ButtonPressed.getHashCode();							// Is is BUTTON_PRESSED or BUTTON_RELEASED//	ev.window.windowid		= windowID;//	ev.key.repeat 			= repeat;							// Is repeat on or off?	ev.key.keycode			= key;								// Which key button state has changed.	ev.key.mod 				= mods;							// Save the modifier keys.//	windowEventServer->getMediator()->fireEvent(ev);}- (void)flagsChanged:(NSEvent *)event{//    int action;//    unsigned int newModifierFlags =//        [event modifierFlags] & NSDeviceIndependentModifierFlagsMask;////    if (newModifierFlags > window->ns.modifierFlags)//        action = GLFW_PRESS;//    else//        action = GLFW_RELEASE;////    window->ns.modifierFlags = newModifierFlags;////    const int key = translateKey([event keyCode]);//    const int mods = translateFlags([event modifierFlags]);//    _glfwInputKey(window, key, [event keyCode], action, mods);}- (void)keyUp:(NSEvent *)event{//    const int key = translateKey([event keyCode]);//    const int mods = translateFlags([event modifierFlags]);//    _glfwInputKey(window, key, [event keyCode], GLFW_RELEASE, mods);}- (void)scrollWheel:(NSEvent *)event{//    double deltaX, deltaY;////#if MAC_OS_X_VERSION_MAX_ALLOWED >= 1070//    if (floor(NSAppKitVersionNumber) > NSAppKitVersionNumber10_6)//    {//        deltaX = [event scrollingDeltaX];//        deltaY = [event scrollingDeltaY];////        if ([event hasPreciseScrollingDeltas])//        {//            deltaX *= 0.1;//            deltaY *= 0.1;//        }//    }//    else//#endif /*MAC_OS_X_VERSION_MAX_ALLOWED*///    {//        deltaX = [event deltaX];//        deltaY = [event deltaY];//    }////    if (fabs(deltaX) > 0.0 || fabs(deltaY) > 0.0)//        _glfwInputScroll(window, deltaX, deltaY);}- (void)resetCursorRects{    // This makes the cursor dissapear when the window is    // resized or received a drag operation//    [self discardCursorRects]; //   [self addCursorRect:[self bounds] cursor:_glfw.ns.cursor];}- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender{//    if ((NSDragOperationGeneric & [sender draggingSourceOperationMask])//        == NSDragOperationGeneric)//    {//        [self setNeedsDisplay:YES];//        return NSDragOperationGeneric;//    }    return NSDragOperationNone;}- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender{    [self setNeedsDisplay:YES];    return YES;}- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender{//    NSPasteboard* pasteboard = [sender draggingPasteboard];//    NSArray* files = [pasteboard propertyListForType:NSFilenamesPboardType];////    int height;//    _glfwPlatformGetWindowSize(window, NULL, &height);//    _glfwInputCursorMotion(window,//                           [sender draggingLocation].x,//                           height - [sender draggingLocation].y);////    const int count = [files count];//    if (count)//    {//        NSEnumerator* e = [files objectEnumerator];//        char** names = calloc(count, sizeof(char*));//        int i;////        for (i = 0;  i < count;  i++)//            names[i] = strdup([[e nextObject] UTF8String]);////        _glfwInputDrop(window, count, (const char**) names);////        for (i = 0;  i < count;  i++)//            free(names[i]);//        free(names);//    }    return YES;}- (void)concludeDragOperation:(id <NSDraggingInfo>)sender{    [self setNeedsDisplay:YES];}@end