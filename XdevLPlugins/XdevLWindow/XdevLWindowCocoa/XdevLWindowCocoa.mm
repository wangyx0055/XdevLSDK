/*	XdevL eXtended DEVice Library.	Copyright Â© 2005-2013 Cengiz Terzibas	This library is free software; you can redistribute it and/or modify it under the	terms of the GNU Lesser General Public License as published by the Free Software	Foundation; either version 2.1 of the License, or (at your option) any later version.	This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;	without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public License along with	this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place,	Suite 330, Boston, MA 02111-1307 USA	I would appreciate if you report all bugs to: cengiz@terzibas.de*/#include <sstream>#include "XdevLWindowCocoa.h"xdl::XdevLModuleDescriptor windowCocoaModuleDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[0],	xdl::window_copyright,	xdl::windowDescription,	xdl::XdevLWindowMajorVersion,	xdl::XdevLWindowMinorVersion,	xdl::XdevLWindowPatchVersion};xdl::XdevLModuleDescriptor windowEventServerModuleDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[2],	xdl::window_copyright,	xdl::windowServerDescription,	xdl::XdevLWindowEventServerMajorVersion,	xdl::XdevLWindowEventServerMinorVersion,	xdl::XdevLWindowEventServerPatchVersion};xdl::XdevLModuleDescriptor cursorModuleDesc {	xdl::window_vendor,	xdl::window_author,	xdl::window_moduleNames[3],	xdl::window_copyright,	xdl::windowServerDescription,	xdl::XdevLWindowEventServerMajorVersion,	xdl::XdevLWindowEventServerMinorVersion,	xdl::XdevLWindowEventServerPatchVersion};xdl::XdevLPluginDescriptor m_windowCarbonPluginDescriptor {	xdl::windowPluginName,	xdl::window_moduleNames,	xdl::XdevLWindowPluginMajorVersion,	xdl::XdevLWindowPluginMinorVersion,	xdl::XdevLWindowPluginPatchVersion};static xdl::xdl_int reference_counter = 0;xdl::XdevLWindowCocoaEventServer* windowEventServerCocoa = nullptr;extern "C" XDEVL_EXPORT int _create(xdl::XdevLModuleCreateParameter* parameter) {	if(reference_counter == 0) {		reference_counter++;		// If there is not event server first create one.		if(xdl::windowEventServer == nullptr) {			// If there is no even server active, create and activate it.			xdl::windowEventServer = static_cast<xdl::XdevLWindowCocoaEventServer*>(parameter->getMediator()->createModule(xdl::XdevLModuleName("XdevLWindowEventServer"), xdl::XdevLID("XdevLWindowEventServer"), xdl::XdevLPluginName("XdevLWindowCocoa")));		}	}	if(windowCocoaModuleDesc.getName() == parameter->getModuleName()) {		xdl::XdevLWindowCocoa* window = new xdl::XdevLWindowCocoa(parameter);		parameter->setModuleInstance(window);	} else if(xdl::XdevLWindowServerImpl::m_windowServerModuleDesc.getName() == parameter->getModuleName()) {		xdl::XdevLWindowCocoaEventServer* windowServer = new xdl::XdevLWindowCocoaEventServer(parameter);		parameter->setModuleInstance(windowServer);	}  else if(cursorModuleDesc.getName() == parameter->getModuleName()) {		xdl::XdevLCursorCocoa* cursor = new xdl::XdevLCursorCocoa(parameter);		parameter->setModuleInstance(cursor);	} else if(windowEventServerModuleDesc.getName() == parameter->getModuleName()) {		windowEventServerCocoa = new xdl::XdevLWindowCocoaEventServer(parameter);		xdl::windowEventServer = windowEventServerCocoa;		parameter->setModuleInstance(xdl::windowEventServer);		xdl::XdevLWindowEventServerParameter = parameter;	} else {		return xdl::ERR_MODULE_NOT_FOUND;	}	return xdl::ERR_OK;}extern "C" XDEVL_EXPORT void _delete(xdl::XdevLModule* obj) {	if(obj)		delete obj;	reference_counter--;	// Only Quit SDL if this is the last module.	if(reference_counter == 0) {		// If the last window was destroy make sure to destroy the event server too.		if(xdl::windowEventServer != nullptr) {			xdl::XdevLWindowEventServerParameter->getMediator()->deleteModule(xdl::windowEventServer->getID());			xdl::windowEventServer = nullptr;		}	}}extern "C" XDEVL_EXPORT xdl::XdevLPluginDescriptor* _getDescriptor()  {	return &m_windowCarbonPluginDescriptor;}namespace xdl {	XdevLWindowCocoa::XdevLWindowCocoa(XdevLModuleCreateParameter* parameter) :		XdevLWindowImpl(XdevLWindowImpl::getWindowsCounter(), parameter, windowCocoaModuleDesc) {	}	xdl_int XdevLWindowCocoa::init() {		// Do the internal initialization.		if(XdevLWindowImpl::init() == ERR_ERROR) {			return ERR_ERROR;		}		return create();	}	xdl_int XdevLWindowCocoa::shutdown() {		return ERR_ERROR;	}	xdl_int XdevLWindowCocoa::create() {		NSAutoreleasePool*	pool = [[NSAutoreleasePool alloc] init];		NSRect 				rect;		NSArray*			screens = [NSScreen screens];				xdl_uint 			style = NSBorderlessWindowMask;		if(xdl_true == m_border) {			style = (NSTitledWindowMask|NSClosableWindowMask|NSMiniaturizableWindowMask|NSResizableWindowMask);		}		rect.origin.x		= m_position.x;		rect.origin.y		= m_position.y;		rect.size.width		= m_size.width;		rect.size.height	= m_size.height;		NSScreen *screen = nil;		for(NSScreen* candidate in screens) {			NSRect screenRect = [candidate frame];			if(rect.origin.x >= screenRect.origin.x &&			        rect.origin.x < screenRect.origin.x + screenRect.size.width &&			        rect.origin.y >= screenRect.origin.y &&			        rect.origin.y < screenRect.origin.y + screenRect.size.height) {				screen = candidate;				rect.origin.x -= screenRect.origin.x;				rect.origin.y -= screenRect.origin.y;			}		}		@try {			m_window = [[NSWindow alloc] initWithContentRect:rect styleMask:style backing:NSBackingStoreBuffered defer:NO screen:screen];		}		@catch(NSException *e) {			XDEVL_MODULE_ERROR([[e reason] UTF8String] << std::endl);			[pool release];			return ERR_ERROR;		}		rect = [m_window contentRectForFrameRect:[m_window frame]];		NSView *view = [[NSView alloc] initWithFrame:rect];				[m_window setContentView: view];		[view release];		[m_window registerForDraggedTypes:[NSArray arrayWithObject:(NSString *)kUTTypeFileURL]];				setTitle(m_title);		m_delegate = [[XdevLWindowDelegate alloc] init:windowEventServerCocoa :this];		if (m_delegate == nil)		{			XDEVL_MODULE_ERROR("Could not create XdevLWindowDelegate\n");			return ERR_ERROR;		}		[NSApp setDelegate:m_delegate];		[pool release];		return ERR_OK;	}	xdl_int XdevLWindowCocoa::update() {//		NSUInteger eventMask = NSLeftMouseDownMask|//        NSLeftMouseUpMask|//        NSMouseMovedMask|//        NSMouseEnteredMask|//        NSMouseExitedMask|//        NSLeftMouseDraggedMask;//		//		NSEvent* event = [m_window nextEventMatchingMask:eventMask //                                            untilDate:[NSDate distantFuture]//                                               inMode:NSDefaultRunLoopMode //                                              dequeue:YES];	NSEvent * event;    do    {        event = [m_window nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES];		//            //Convert the cocoa events to something useful here and add them to your own event queue////        [NSApp sendEvent: event];    }    while(event != nil);				return ERR_ERROR;	}	void* XdevLWindowCocoa::getInternal(const XdevLInternalName& id) {		return nullptr;	}	void XdevLWindowCocoa::showPointer() {	}	void XdevLWindowCocoa::hidePointer() {	}	void XdevLWindowCocoa::setPointerPosition(xdl_uint x, xdl_uint y) {	}	void XdevLWindowCocoa::clipPointerPosition(xdl_uint x, xdl_uint y, xdl_uint width, xdl_uint height)  {	}	void XdevLWindowCocoa::grabPointer() {	}	void XdevLWindowCocoa::ungrabPointer() {	}	void XdevLWindowCocoa::grabKeyboard() {	}	void XdevLWindowCocoa::ungrabKeyboard() {	}	const XdevLWindowPosition& XdevLWindowCocoa::getPosition() {		return m_position;	}	const XdevLWindowSize& XdevLWindowCocoa::getSize() {		return m_size;	}	XdevLWindowPosition::type XdevLWindowCocoa::getX() {		return m_position.x;	}	XdevLWindowPosition::type XdevLWindowCocoa::getY() {		return m_position.y;	}	XdevLWindowSize::type XdevLWindowCocoa::getWidth() {		return m_size.width;	}	XdevLWindowSize::type XdevLWindowCocoa::getHeight() {		return m_size.height;	}	const XdevLWindowTitle& XdevLWindowCocoa::getTitle() {		return m_title;	}	xdl_bool  XdevLWindowCocoa::getFullscreen() {		return XdevLWindowImpl::getFullscreen();	}	void XdevLWindowCocoa::setFullscreen(xdl_bool state) {	}	void XdevLWindowCocoa::show() {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		if (![m_window isMiniaturized]) {//			[windowData->listener pauseVisibleObservation];			[m_window makeKeyAndOrderFront:nil];//			[windowData->listener resumeVisibleObservation];		}		[pool release];	}	void XdevLWindowCocoa::setX(XdevLWindowPosition::type x) {	}	void XdevLWindowCocoa::setY(XdevLWindowPosition::type y) {	}	void XdevLWindowCocoa::setWidth(XdevLWindowSize::type width) {	}	void XdevLWindowCocoa::setHeight(XdevLWindowSize::type height) {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		NSSize size;		size.width = getWidth();		setHeight(height);		size.height = getHeight();		[m_window setContentSize:size];		[pool release];	}	void XdevLWindowCocoa::setTitle(const XdevLWindowTitle& title) {		m_title = title;		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		NSString* string = [[NSString alloc] initWithUTF8String:m_title.toString().c_str()];		[m_window setTitle:string];		[string release];		[pool release];	}	xdl_int  XdevLWindowCocoa::getColorDepth() {		return XdevLWindowImpl::getColorDepth();	}	xdl_bool XdevLWindowCocoa::isHidden() {		return xdl_false; // TODO This may cause problems.	}	void XdevLWindowCocoa::raise() {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		[m_window makeKeyAndOrderFront:nil];		[pool release];	}	xdl_bool  XdevLWindowCocoa::getHidePointer() {		return XdevLWindowImpl::getHidePointer();	}	void XdevLWindowCocoa::setInputFocus() {	}	void XdevLWindowCocoa::hide() {		NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];		[m_window orderOut:nil];		[pool release];	}	void XdevLWindowCocoa::setSize(const XdevLWindowSize& size) {		m_size = size;	}	void XdevLWindowCocoa::setPosition(const XdevLWindowPosition& position) {		m_position = position;	}	xdl_bool XdevLWindowCocoa::hasFocus() {		return xdl_false;	}	void XdevLWindowCocoa::setType(XdevLWindowTypes type) {		m_windowType = type;	}	void XdevLWindowCocoa::setParent(XdevLWindow* window) {		XdevLWindowImpl::setParent(window);	}	//	// -------------------------------------------------------------------------	//	XdevLWindowServerCocoa::XdevLWindowServerCocoa(XdevLModuleCreateParameter* parameter) :		XdevLWindowServerImpl(parameter) {	}	XdevLWindowServerCocoa::~XdevLWindowServerCocoa() {	}	xdl_int XdevLWindowServerCocoa::createWindow(XdevLWindow** window,	        const XdevLWindowTitle& title,	        const XdevLWindowPosition& position,	        const XdevLWindowSize& size) {//		XdevLWindowSDL* sdlWindow = new XdevLWindowSDL(nullptr);//		sdlWindow->setTitle(title);//		sdlWindow->setPosition(position);//		sdlWindow->setSize(size);//		sdlWindow->setWindowDecoration(xdl_false);//		sdlWindow->create();//		*window = sdlWindow;//		m_windowList[sdlWindow->getWindowID()] = sdlWindow;		return ERR_OK;	}	XdevLWindowCocoaEventServer::XdevLWindowCocoaEventServer(XdevLModuleCreateParameter* parameter) :		XdevLWindowEventServerImpl(parameter, windowEventServerModuleDesc)	{}	xdl_int XdevLWindowCocoaEventServer::registerWindowForEvents(XdevLWindow* window) {		return XdevLWindowEventServerImpl::registerWindowForEvents(window);	}	xdl_int XdevLWindowCocoaEventServer::unregisterWindowFromEvents(XdevLWindow* window) {		return XdevLWindowEventServerImpl::unregisterWindowFromEvents(window);	}	xdl_int XdevLWindowCocoaEventServer::init() {		XDEVL_MODULE_SUCCESS("Window created successfully" << std::endl);		return ERR_OK;	}	void* XdevLWindowCocoaEventServer::getInternal(const XdevLInternalName& id) {		return nullptr;	}	xdl_int XdevLWindowCocoaEventServer::shutdown() {		XDEVL_MODULE_SUCCESS("Shutdown process was successful.\n");		return ERR_OK;	}	xdl_int XdevLWindowCocoaEventServer::update() {		return ERR_ERROR;	}	void XdevLWindowCocoaEventServer::flush() {	}//// -----------------------------------------------------------------------------//	XdevLCursorCocoa::XdevLCursorCocoa(XdevLModuleCreateParameter* parameter) :		XdevLModuleImpl<XdevLCursor>(parameter, cursorModuleDesc)  {	}	xdl_int XdevLCursorCocoa::init() {		return ERR_OK;	}	xdl_int XdevLCursorCocoa::shutdown() {		return ERR_OK;	}	void* XdevLCursorCocoa::getInternal(const XdevLInternalName& id) {		return nullptr;	}	void XdevLCursorCocoa::show() {	}	void XdevLCursorCocoa::hide() {	}	void XdevLCursorCocoa::setPosition(xdl_uint x, xdl_uint y) {	}	xdl_int XdevLCursorCocoa::clip(xdl_uint x, xdl_uint y, xdl_uint width, xdl_uint height) {		return ERR_ERROR;	}	void XdevLCursorCocoa::releaseClip() {	}	xdl_int XdevLCursorCocoa::enableRelativeMotion() {		return ERR_ERROR;	}	void XdevLCursorCocoa::disableRelativeMotion() {	}} // End of namespace@implementation XdevLWindowDelegate- (id)init:(xdl::XdevLWindowCocoaEventServer *)windowEventServer :(xdl::XdevLWindowCocoa*)window{    self = [super init];    if (self != nil) {        m_windowEventServer = windowEventServer;		m_window = window;	}    return self;}- (BOOL)windowShouldClose:(id)sender{	xdl::XdevLEvent ev;	ev.type					= xdl::XDEVL_WINDOW_EVENT;	ev.window.event 		= xdl::XDEVL_WINDOW_CLOSE;	ev.window.windowid		= m_window->getWindowID();	m_window->getMediator()->fireEvent(ev);	// Make a core event.	ev.type					= xdl::XDEVL_CORE_EVENT;	ev.core.event 			= xdl::XDEVL_CORE_SHUTDOWN;	m_window->getMediator()->fireEvent(ev);    	return NO;}- (void)windowDidResize:(NSNotification *)notification{//    [window->nsgl.context update];////    const NSRect contentRect = [window->ns.view frame];//    const NSRect fbRect = convertRectToBacking(window, contentRect);////    _glfwInputFramebufferSize(window, fbRect.size.width, fbRect.size.height);//    _glfwInputWindowSize(window, contentRect.size.width, contentRect.size.height);//    _glfwInputWindowDamage(window);////    if (window->cursorMode == GLFW_CURSOR_DISABLED)//        centerCursor(window);}- (void)windowDidMove:(NSNotification *)notification{//    [window->nsgl.context update];////    int x, y;//    _glfwPlatformGetWindowPos(window, &x, &y);//    _glfwInputWindowPos(window, x, y);////    if (window->cursorMode == GLFW_CURSOR_DISABLED)//        centerCursor(window);}- (void)windowDidMiniaturize:(NSNotification *)notification{ //   _glfwInputWindowIconify(window, GL_TRUE);}- (void)windowDidDeminiaturize:(NSNotification *)notification{//    if (window->monitor)//        enterFullscreenMode(window);////    _glfwInputWindowIconify(window, GL_FALSE);}- (void)windowDidBecomeKey:(NSNotification *)notification{//    _glfwInputWindowFocus(window, GL_TRUE);//    _glfwPlatformSetCursorMode(window, window->cursorMode);}- (void)windowDidResignKey:(NSNotification *)notification{//    _glfwInputWindowFocus(window, GL_FALSE);//    _glfwPlatformSetCursorMode(window, GLFW_CURSOR_NORMAL);}@end